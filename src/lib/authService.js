// src/lib/authService.js
// üîê SERVICIO DE AUTENTICACI√ìN - CLUB CANINO DOS HUELLITAS
// ‚úÖ CORREGIDO: Singleton pattern para evitar m√∫ltiples instancias

import supabase from './supabase.js';

// ============================================
// üîß SINGLETON PATTERN
// ============================================
let authServiceInstance = null;
let isInitializing = false;

class AuthService {
  constructor() {
    // Prevenir m√∫ltiples instancias
    if (authServiceInstance) {
      console.log('‚ö†Ô∏è AuthService ya existe, devolviendo instancia existente');
      return authServiceInstance;
    }

    console.log('üîß Creando nueva instancia de AuthService');
    
    // Estado de autenticaci√≥n
    this.user = null;
    this.profile = null;
    this.isInitialized = false;
    this.isAuthenticated = false;
    this.listeners = new Set();
    this.sessionCheckInterval = null;
    this.authStateListener = null;
    
    // Cache para evitar re-ejecutar operaciones
    this.initializationPromise = null;
    this.profileLoadPromise = null;
    
    // Bind methods
    this.initialize = this.initialize.bind(this);
    this.signIn = this.signIn.bind(this);
    this.signOut = this.signOut.bind(this);
    
    // Marcar como instancia singleton
    authServiceInstance = this;
  }

  // ===============================================
  // üöÄ INICIALIZACI√ìN CON CACHE
  // ===============================================

  async initialize() {
    // Si ya est√° inicializado, devolver inmediatamente
    if (this.isInitialized) {
      console.log('‚úÖ AuthService ya inicializado, devolviendo estado actual');
      return true;
    }

    // Si ya est√° inicializando, esperar a que termine
    if (this.initializationPromise) {
      console.log('üîÑ AuthService ya inicializando, esperando...');
      return await this.initializationPromise;
    }

    // Solo en el cliente
    if (typeof window === 'undefined') {
      console.log('‚ö†Ô∏è Entorno servidor - saltando inicializaci√≥n');
      return false;
    }

    // Crear promise de inicializaci√≥n para evitar m√∫ltiples llamadas
    this.initializationPromise = this.performInitialization();
    
    try {
      const result = await this.initializationPromise;
      return result;
    } catch (error) {
      this.initializationPromise = null; // Reset en caso de error
      throw error;
    }
  }

  async performInitialization() {
    try {
      console.log('üîÑ AuthService: Inicializando (√∫nica vez)...');
      
      // Verificar sesi√≥n de Supabase
      console.log('üîç Verificando sesi√≥n de Supabase...');
      const { data: sessionData, error: sessionError } = await supabase.auth.getSession();
      
      if (sessionError) {
        console.warn('‚ö†Ô∏è Error obteniendo sesi√≥n:', sessionError);
      }

      if (sessionData?.session?.user) {
        console.log('‚úÖ Sesi√≥n activa encontrada:', sessionData.session.user.email);
        await this.loadUserProfile(sessionData.session.user);
      } else {
        console.log('‚ùå No hay sesi√≥n activa en Supabase');
        this.clearAuthState();
      }

      // Configurar listener de cambios (solo una vez)
      this.setupAuthListener();

      this.isInitialized = true;
      console.log('‚úÖ AuthService inicializado correctamente');
      return true;
      
    } catch (error) {
      console.error('‚ùå Error en inicializaci√≥n:', error);
      this.clearAuthState();
      return false;
    }
  }

  setupAuthListener() {
    // Remover listener previo si existe
    if (this.authStateListener) {
      console.log('üîÑ Removiendo listener previo de auth');
      this.authStateListener.subscription?.unsubscribe?.();
    }

    console.log('üîó Configurando listener de auth state changes (√∫nico)');
    
    this.authStateListener = supabase.auth.onAuthStateChange(async (event, session) => {
      console.log('üîÑ Auth state change:', event);
      
      // Debounce para evitar m√∫ltiples llamadas r√°pidas
      if (this.authChangeTimeout) {
        clearTimeout(this.authChangeTimeout);
      }
      
      this.authChangeTimeout = setTimeout(async () => {
        await this.handleAuthStateChange(event, session);
      }, 100);
    });
  }

  // ===============================================
  // üîÑ GESTI√ìN DE ESTADO DE AUTH
  // ===============================================

  async handleAuthStateChange(event, session) {
    try {
      switch (event) {
        case 'SIGNED_IN':
          if (session?.user && session.user.id !== this.user?.id) {
            console.log('‚úÖ Usuario logueado:', session.user.email);
            await this.loadUserProfile(session.user);
          }
          break;
          
        case 'SIGNED_OUT':
          console.log('üëã Usuario deslogueado');
          this.clearAuthState();
          break;
          
        case 'TOKEN_REFRESHED':
          console.log('üîÑ Token renovado');
          // No recargar perfil en refresh, solo verificar sesi√≥n
          if (session?.user && !this.user) {
            await this.loadUserProfile(session.user);
          }
          break;
          
        default:
          console.log('üîÑ Auth event:', event);
      }
      
      // Notificar cambios (con debounce)
      this.debouncedNotifyListeners();
      
    } catch (error) {
      console.error('‚ùå Error manejando auth state change:', error);
    }
  }

  // ===============================================
  // üë§ GESTI√ìN DE PERFIL CON CACHE
  // ===============================================

  async loadUserProfile(user) {
    try {
      // Si ya estamos cargando el perfil para este usuario, esperar
      if (this.profileLoadPromise && this.user?.id === user.id) {
        console.log('üîÑ Ya cargando perfil para este usuario, esperando...');
        return await this.profileLoadPromise;
      }

      console.log('üîÑ Cargando perfil para:', user.email);
      
      if (!user || !user.id) {
        throw new Error('Usuario inv√°lido');
      }

      // Crear promise para evitar m√∫ltiples cargas
      this.profileLoadPromise = this.performProfileLoad(user);
      
      try {
        const result = await this.profileLoadPromise;
        return result;
      } finally {
        this.profileLoadPromise = null;
      }
      
    } catch (error) {
      console.error('‚ùå Error cargando perfil:', error);
      this.clearAuthState();
      throw error;
    }
  }

  async performProfileLoad(user) {
    // Obtener perfil de la base de datos
    const { data: profile, error } = await supabase
      .from('profiles')
      .select('*')
      .eq('id', user.id)
      .single();

    if (error) {
      console.error('‚ùå Error obteniendo perfil de DB:', error);
      throw error;
    }

    if (!profile) {
      throw new Error('Perfil no encontrado para el usuario');
    }

    // Actualizar estado
    this.user = user;
    this.profile = profile;
    this.isAuthenticated = true;

    console.log('‚úÖ Perfil cargado exitosamente:', {
      email: user.email,
      role: profile.role,
      name: profile.full_name
    });

    return { user, profile };
  }

  // ===============================================
  // üîê AUTENTICACI√ìN
  // ===============================================

  async signIn(email, password) {
    try {
      console.log('üîÑ Intentando login para:', email);
      
      // Validaci√≥n b√°sica
      if (!email || !password) {
        return {
          success: false,
          error: 'Email y contrase√±a son requeridos'
        };
      }

      // Asegurar inicializaci√≥n
      if (!this.isInitialized) {
        console.log('üîÑ Inicializando AuthService...');
        await this.initialize();
      }

      // Limpiar estado previo
      this.clearAuthState();

      // Intentar login con Supabase
      const { data, error } = await supabase.auth.signInWithPassword({
        email: email.trim().toLowerCase(),
        password: password
      });

      if (error) {
        console.error('‚ùå Error en signIn:', error);
        return {
          success: false,
          error: this.getErrorMessage(error)
        };
      }

      if (!data.user) {
        return {
          success: false,
          error: 'No se pudo obtener informaci√≥n del usuario'
        };
      }

      // Cargar perfil
      const profileResult = await this.loadUserProfile(data.user);
      
      console.log('‚úÖ Login exitoso para:', email);
      
      return {
        success: true,
        user: data.user,
        profile: profileResult.profile
      };

    } catch (error) {
      console.error('‚ùå Error en signIn:', error);
      return {
        success: false,
        error: error.message || 'Error al iniciar sesi√≥n'
      };
    }
  }

  async signOut() {
    try {
      console.log('üîÑ Cerrando sesi√≥n...');
      
      // Cerrar sesi√≥n en Supabase
      const { error } = await supabase.auth.signOut();
      
      if (error) {
        console.error('‚ùå Error en signOut de Supabase:', error);
      }

      // Limpiar estado local
      this.clearAuthState();
      
      console.log('‚úÖ Sesi√≥n cerrada correctamente');
      
      return { success: true };
      
    } catch (error) {
      console.error('‚ùå Error cerrando sesi√≥n:', error);
      
      // Forzar limpieza local
      this.clearAuthState();
      
      return {
        success: false,
        error: error.message
      };
    }
  }

  // ===============================================
  // üßπ LIMPIEZA DE ESTADO
  // ===============================================

  clearAuthState() {
    this.user = null;
    this.profile = null;
    this.isAuthenticated = false;
    this.notifyListeners();
    console.log('üßπ Estado de auth limpiado');
  }

  // ===============================================
  // üîî NOTIFICACIONES CON DEBOUNCE
  // ===============================================

  debouncedNotifyListeners() {
    // Evitar m√∫ltiples notificaciones r√°pidas
    if (this.notifyTimeout) {
      clearTimeout(this.notifyTimeout);
    }
    
    this.notifyTimeout = setTimeout(() => {
      this.notifyListeners();
    }, 50);
  }

  addListener(callback) {
    this.listeners.add(callback);
    console.log('üîó Listener agregado, total:', this.listeners.size);
    return () => {
      this.listeners.delete(callback);
      console.log('üîó Listener removido, total:', this.listeners.size);
    };
  }

  notifyListeners() {
    const authState = {
      user: this.user,
      profile: this.profile,
      isAuthenticated: this.isAuthenticated
    };

    console.log('üîî Notificando', this.listeners.size, 'listeners');
    
    this.listeners.forEach(callback => {
      try {
        callback(authState);
      } catch (error) {
        console.error('‚ùå Error en listener:', error);
      }
    });
  }

  // ===============================================
  // üßπ LIMPIEZA DE ESTADO
  // ===============================================

  clearAuthState() {
    const wasAuthenticated = this.isAuthenticated;
    
    this.user = null;
    this.profile = null;
    this.isAuthenticated = false;
    
    if (wasAuthenticated) {
      console.log('üßπ Estado de auth limpiado');
      this.debouncedNotifyListeners();
    }
  }

  // ===============================================
  // üîÑ CLEANUP AL DESTRUIR
  // ===============================================

  cleanup() {
    console.log('üßπ Limpiando AuthService...');
    
    // Limpiar timeouts
    if (this.authChangeTimeout) {
      clearTimeout(this.authChangeTimeout);
    }
    if (this.notifyTimeout) {
      clearTimeout(this.notifyTimeout);
    }
    
    // Remover auth listener
    if (this.authStateListener) {
      this.authStateListener.subscription?.unsubscribe?.();
    }
    
    // Limpiar listeners
    this.listeners.clear();
    
    // Reset singleton
    if (authServiceInstance === this) {
      authServiceInstance = null;
    }
  }

  // ===============================================
  // üõ†Ô∏è UTILIDADES (SIN CAMBIOS)
  // ===============================================

  getErrorMessage(error) {
    const errorMessages = {
      'Invalid login credentials': 'Credenciales incorrectas',
      'Email not confirmed': 'Email no confirmado',
      'Too many requests': 'Demasiados intentos, intenta m√°s tarde',
      'Invalid email': 'Email inv√°lido',
      'Network request failed': 'Error de conexi√≥n, verifica tu internet'
    };

    return errorMessages[error.message] || error.message || 'Error desconocido';
  }

  getDashboardUrl() {
    if (!this.isAuthenticated || !this.profile) {
      return '/login/';
    }

    const roleRoutes = {
      'padre': '/dashboard/padre/',
      'profesor': '/dashboard/profesor/',
      'admin': '/dashboard/admin/',
      'conductor': '/dashboard/conductor/'
    };

    return roleRoutes[this.profile.role] || '/dashboard/padre/';
  }

  hasRole(role) {
    return this.isAuthenticated && this.profile?.role === role;
  }

  isLoggedIn() {
    return this.isAuthenticated && this.user && this.profile;
  }

  getCurrentUser() {
    return {
      user: this.user,
      profile: this.profile,
      isAuthenticated: this.isAuthenticated
    };
  }
}

// ===============================================
// üöÄ FUNCI√ìN SINGLETON PARA OBTENER INSTANCIA
// ===============================================

function getAuthServiceInstance() {
  if (!authServiceInstance) {
    console.log('üîß Creando primera instancia de AuthService');
    authServiceInstance = new AuthService();
  }
  return authServiceInstance;
}

// ===============================================
// üîÑ AUTO-INICIALIZACI√ìN MEJORADA
// ===============================================

// Crear instancia √∫nica
const authService = getAuthServiceInstance();

// Auto-inicializaci√≥n en el cliente (con protecci√≥n)
if (typeof window !== 'undefined') {
  // Verificar si ya se est√° inicializando
  if (!isInitializing) {
    isInitializing = true;
    
    const initializeAuth = async () => {
      try {
        if (document.readyState === 'loading') {
          await new Promise(resolve => {
            document.addEventListener('DOMContentLoaded', resolve);
          });
        }
        
        console.log('üöÄ Auto-inicializando AuthService...');
        await authService.initialize();
        isInitializing = false;
        
      } catch (error) {
        console.error('‚ùå Error en auto-inicializaci√≥n:', error);
        isInitializing = false;
      }
    };

    initializeAuth();
  }
  
  // Cleanup al cerrar ventana
  window.addEventListener('beforeunload', () => {
    authService.cleanup();
  });
}

// ‚úÖ EXPORTACIONES COMPATIBLES CON AUTHPROVIDER
export default authService;           // Para import authService from './authService.js'
export { authService };              // Para import { authService } from './authService.js'